// synthesis VERILOG_INPUT_VERSION SYSTEMVERILOG_2012
//
// NOTE: this file is autogenerated! Modifications will be lost.
//
// input layer, Verifier
// (C) 2016 Riad S. Wahby <rsw@cs.nyu.edu>

`include "simulator.v"
`include "field_arith_defs.v"
`include "vpintf_defs.v"
`include "verifier_compute_io.sv"
module verifier_input () ;

{0}
localparam nInBits = $clog2(nInputs);
localparam nValBits = nCopyBits + nInBits;
localparam nInputsRnd = 1 << nInBits;
localparam nCopies = 1 << nCopyBits;
localparam nValues = 1 << nValBits;

reg clk, rstb;
reg [`F_NBITS-1:0] invals [(nCopies*nInputs)-1:0];
wire [`F_NBITS-1:0] vals_in [nValues-1:0];
reg [`F_NBITS-1:0] z1 [nInBits-1:0];
reg [`F_NBITS-1:0] z2 [nCopyBits-1:0];
wire [`F_NBITS-1:0] tau [nValBits-1:0];
reg [63:0] field_counts [5:0];

reg [`F_NBITS-1:0] mlext_expect;
wire [`F_NBITS-1:0] mlext_out;

enum {{ ST_START, ST_RUN_ST, ST_RUN }} state_reg, state_next;
wire en_chi = state_reg == ST_RUN_ST;
wire ready;

genvar CopyNum;
genvar InNum;
generate
    for (CopyNum = 0; CopyNum < nCopies; CopyNum = CopyNum + 1) begin
        localparam nOffset_out = CopyNum * nInputsRnd;
        localparam nOffset_in = CopyNum * nInputs;
        for (InNum = 0; InNum < nInputs; InNum = InNum + 1) begin
            assign vals_in[nOffset_out + InNum] = invals[nOffset_in + InNum];
        end
        for (InNum = nInputs; InNum < nInputsRnd; InNum = InNum + 1) begin
            assign vals_in[nOffset_out + InNum] = {{(`F_NBITS){{1'b0}}}};
        end
    end
    for (InNum = 0; InNum < nValBits; InNum = InNum + 1) begin
        if (InNum < nInBits) begin
            assign tau[InNum] = z1[InNum];
        end else begin
            assign tau[InNum] = z2[InNum - nInBits];
        end
    end
endgenerate

integer i;
initial begin
    $dumpfile("verifier_input.fst");
    $dumpvars;
    if (defDebug == 1) begin
        for (i = 0; i < nValues; i = i + 1) begin
            $dumpvars(0, vals_in[i]);
        end
    end
    $display("id #%d", $vpintf_init(`V_TYPE_IN, 0));
    clk = 0;
    rstb = 1;
    state_reg = ST_START;
    #1 rstb = 0;
    #3 rstb = 1;
end

`ALWAYS_COMB begin
    state_next = state_reg;

    case (state_reg)
        ST_START: begin
            state_next = ST_RUN_ST;
        end

        ST_RUN_ST, ST_RUN: begin
            if (~en_chi & ready) begin
                state_next = ST_START;
            end else begin
                state_next = ST_RUN;
            end
        end
    endcase
end

`ALWAYS_FF @(clk) begin
    clk <= #1 ~clk;
end

`ALWAYS_FF @(posedge clk or negedge rstb) begin
    if (~rstb) begin
        state_reg <= ST_START;
    end else begin
        state_reg <= state_next;
        if (~en_chi & ready & (state_reg == ST_RUN)) begin
            if (mlext_expect == mlext_out) begin
                $vpintf_send(`V_SEND_OKAY, 0, mlext_out);
            end else begin
                $vpintf_send(`V_SEND_NOKAY, 0, mlext_out);
            end
            $f_getcnt(field_counts);
            $vpintf_send(`V_SEND_COUNTS, 6, field_counts);
            $f_rstcnt();
        end else if (state_reg == ST_START) begin
            if (defDebug == 1) $display("waiting (V_RECV_INPUTS)");
            $vpintf_recv(`V_RECV_INPUTS, nCopies * nInputs, invals);
            if (defDebug == 1) $display("got (V_RECV_INPUTS)");

            if (defDebug == 1) $display("waiting (V_RECV_EXPECT)");
            $vpintf_recv(`V_RECV_EXPECT, 1, mlext_expect);
            if (defDebug == 1) $display("got (V_RECV_EXPECT)");

            if (defDebug == 1) $display("waiting (V_RECV_Z1)");
            $vpintf_recv(`V_RECV_Z1, nInBits, z1);
            if (defDebug == 1) $display("got (V_RECV_Z1)");

            if (defDebug == 1) $display("waiting (V_RECV_Z2)");
            $vpintf_recv(`V_RECV_Z2, nCopyBits, z2);
            if (defDebug == 1) $display("got (V_RECV_Z2)");

        end
    end
end

verifier_compute_io
   #( .nValBits     (nValBits)
    , .nParBits     (nParBitsV)
    ) iInput
    ( .clk          (clk)
    , .rstb         (rstb)
    , .en           (en_chi)
    , .tau          (tau)
    , .vals_in      (vals_in)
    , .mlext_out    (mlext_out)
    , .ready        (ready)
    );

endmodule
