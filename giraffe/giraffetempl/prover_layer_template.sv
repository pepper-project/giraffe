// synthesis VERILOG_INPUT_VERSION SYSTEMVERILOG_2012
//
// NOTE: this file is autogenerated! Modifications will be lost.
//
// Prover layer
// (C) 2016 Riad S. Wahby <rsw@cs.nyu.edu>

`include "simulator.v"
`include "field_arith_defs.v"
`include "vpintf_defs.v"
`include "prover_layer.sv"
module prover_layer_top () ;

{0}
localparam nInBits = $clog2(nInputs);
localparam nOutBits = $clog2(nGates);
localparam nCopies = 1 << nCopyBits;
localparam lastCoeff = nInBits < 3 ? 3 : nInBits;

reg [nMuxSels-1:0] muxsel_reg;
reg [63:0] field_counts [5:0];
reg [`F_NBITS-1:0] z1_chi [nGates-1:0];
reg [`F_NBITS-1:0] z2mz2 [(2*nCopyBits)-1:0];
reg [`F_NBITS-1:0] tau;

wire [`F_NBITS-1:0] z2 [nCopyBits-1:0];
wire [`F_NBITS-1:0] m_z2_p1 [nCopyBits-1:0];
wire z1_chi_out_ready, z2_out_ready, ready, cubic;

wire [`F_NBITS-1:0] z1_chi_out [nInputs-1:0];
wire [`F_NBITS-1:0] z2_out [nCopyBits-1:0];
wire [`F_NBITS-1:0] m_z2_p1_out [nCopyBits-1:0];
wire [`F_NBITS-1:0] z2mz2_out [(2*nCopyBits)-1:0];

wire [`F_NBITS-1:0] coeff_out [lastCoeff:0];

reg [`F_NBITS-1:0] invals [(nCopies*nInputs)-1:0];
wire [`F_NBITS-1:0] v_in [nCopies-1:0] [nInputs-1:0];
genvar CopyNum;
genvar InNum;
genvar GateNum;
generate
    for (CopyNum = 0; CopyNum < nCopies; CopyNum = CopyNum + 1) begin
        localparam nOffset = CopyNum * nInputs;
        for (InNum = 0; InNum < nInputs; InNum = InNum + 1) begin
            assign v_in[CopyNum][InNum] = invals[nOffset + InNum];
        end
    end
    for (GateNum = 0; GateNum < 2 * nCopyBits; GateNum = GateNum + 1) begin
        if (GateNum < nCopyBits) begin
            assign z2[GateNum] = z2mz2[GateNum];
            assign z2mz2_out[GateNum] = z2_out[GateNum];
        end else begin
            assign m_z2_p1[GateNum - nCopyBits] = z2mz2[GateNum];
            assign z2mz2_out[GateNum] = m_z2_p1_out[GateNum - nCopyBits];
        end
    end
endgenerate

reg clk, rstb, restart, z1_chi_in_ready;
enum {{ ST_START, ST_RUN_ST, ST_RUN, ST_RESTART_ST, ST_RESTART }} state_reg, state_next;
wire en_lay = (state_reg == ST_RUN_ST) | (state_reg == ST_RESTART_ST);

wire [`F_NBITS-1:0] invals_wire [nCopies*nInputs-1:0];
generate
    for (GateNum = 0; GateNum < nCopies * nInputs; GateNum = GateNum + 1) begin
        assign invals_wire[GateNum] = invals[GateNum];
    end
endgenerate

integer i;
initial begin
    $dumpfile("prover_layer_{1}.fst");
    $dumpvars;
    if (defDebug == 1) begin
        for (i = 0; i < nGates; i = i + 1) begin
            $dumpvars(0, iLayer.z1_chi[i]);
        end
        for (i = 0; i < nCopyBits; i = i + 1) begin
            $dumpvars(0, iLayer.z2[i], iLayer.m_z2_p1[i]);
        end
        for (i = 0; i < lastCoeff + 1; i = i + 1) begin
            $dumpvars(0, iLayer.coeff_out[i]);
        end
        for (i = 0; i < nCopies * nInputs; i = i + 1) begin
            $dumpvars(0, invals_wire[i]);
        end
        for (i = 0; i < nCopies / 2; i = i + 1) begin
            $dumpvars(0, iLayer.iEarly.point3_vals[i], iLayer.iEarly.point4_vals[i]);
            $dumpvars(0, iLayer.iEarly.point3_shuff[i], iLayer.iEarly.point4_shuff[i]);
            $dumpvars(0, iLayer.iEarly.beta_even_vals[i], iLayer.iEarly.beta_odd_vals[i]);
            $dumpvars(0, iLayer.iEarly.beta_even_shuff[i], iLayer.iEarly.beta_odd_shuff[i]);
        end
        for (i = 0; i < 1 << nParBitsP; i = i + 1) begin
            $dumpvars(0, iLayer.iEarly.iGatesBank.iAddT.in[i]);
        end
    end
    $display("id %d", $vpintf_init(`P_TYPE_LAY, layNum));
    clk = 0;
    rstb = 1;
    restart = 1;
    z1_chi_in_ready = 0;
    state_reg = ST_START;
    #1 rstb = 0;
    #3 rstb = 1;
end

`ALWAYS_COMB begin
    state_next = state_reg;

    case (state_reg)
        ST_START: begin
            state_next = ST_RUN_ST;
        end

        ST_RUN_ST, ST_RUN: begin
            if (~en_lay & ready) begin
                if (z2_out_ready) begin
                    state_next = ST_RESTART_ST;
                end else begin
                    state_next = ST_RUN_ST;
                end
            end else begin
                state_next = ST_RUN;
            end
        end

        ST_RESTART_ST, ST_RESTART: begin
            if (~en_lay & z1_chi_out_ready) begin
                state_next = ST_RUN;
            end else begin
                state_next = ST_RESTART;
            end
        end
    endcase
end

`ALWAYS_FF @(clk) begin
    clk <= #1 ~clk;
end

`ALWAYS_FF @(posedge clk or negedge rstb) begin
    if (~rstb) begin
        state_reg <= ST_START;
    end else begin
        state_reg <= state_next;
        if (state_reg == ST_START) begin
            if (defDebug == 1) $display("waiting (P_RECV_Z2VALS)");
            $vpintf_recv(`P_RECV_Z2VALS, 2 * nCopyBits, z2mz2);
            if (defDebug == 1) $display("got (P_RECV_Z2VALS)");

            if (defDebug == 1) $display("waiting (P_RECV_Z1CHI)");
            $vpintf_recv(`P_RECV_Z1CHI, nGates, z1_chi);
            if (defDebug == 1) $display("got (P_RECV_Z1CHI)");

            $vpintf_send(`P_SEND_RESTART, 0, tau);
            if (defDebug == 1) $display("waiting (P_RECV_LAYVALS)");
            $vpintf_recv(`P_RECV_LAYVALS, nCopies * nInputs, invals);
            if (defDebug == 1) $display("got (P_RECV_LAYVALS)");

            if (defDebug == 1) $display("waiting (P_RECV_MUXSEL)");
            $vpintf_recv(`P_RECV_MUXSEL, 1, muxsel_reg);
            if (defDebug == 1) $display("got (P_RECV_MUXSEL)");

            z1_chi_in_ready <= 1'b1;
        end else if (~en_lay & ready & (state_reg == ST_RUN)) begin
            if (z2_out_ready) begin
                $vpintf_send(`P_SEND_COEFFS, lastCoeff + 1, coeff_out);
            end else if (cubic) begin
                $vpintf_send(`P_SEND_COEFFS, 4, coeff_out);
            end else begin
                $vpintf_send(`P_SEND_COEFFS, 3, coeff_out);
            end
            if (defDebug == 1) $display("waiting (P_RECV_TAU)");
            $vpintf_recv(`P_RECV_TAU, 1, tau);
            if (defDebug == 1) $display("got (P_RECV_TAU)");

            z1_chi_in_ready <= 1'b0;
            restart <= 1'b0;
        end else if (~en_lay & z1_chi_out_ready & (state_reg == ST_RESTART)) begin
            $vpintf_send(`P_SEND_Z2VALS, 2 * nCopyBits, z2mz2_out);
            $vpintf_send(`P_SEND_Z1CHI, nInputs, z1_chi_out);
            $f_getcnt(field_counts);
            $vpintf_send(`P_SEND_COUNTS, 6, field_counts);
            $f_rstcnt();
            if (defDebug == 1) $display("waiting (P_RECV_Z2VALS)");
            $vpintf_recv(`P_RECV_Z2VALS, 2 * nCopyBits, z2mz2);
            if (defDebug == 1) $display("got (P_RECV_Z2VALS)");

            if (defDebug == 1) $display("waiting (P_RECV_Z1CHI)");
            $vpintf_recv(`P_RECV_Z1CHI, nGates, z1_chi);
            if (defDebug == 1) $display("got (P_RECV_Z1CHI)");

            $vpintf_send(`P_SEND_RESTART, 0, tau);
            if (defDebug == 1) $display("waiting (P_RECV_LAYVALS)");
            $vpintf_recv(`P_RECV_LAYVALS, nCopies * nInputs, invals);
            if (defDebug == 1) $display("got (P_RECV_LAYVALS)");

            if (defDebug == 1) $display("waiting (P_RECV_MUXSEL)");
            $vpintf_recv(`P_RECV_MUXSEL, 1, muxsel_reg);
            if (defDebug == 1) $display("got (P_RECV_MUXSEL)");

            z1_chi_in_ready <= 1'b1;
        end
    end
end

prover_layer
   #( .nInputs      (nInputs)
    , .nGates       (nGates)
    , .nMuxSels     (nMuxSels)
    , .nCopyBits    (nCopyBits)
    , .plStages     (plStages)
    , .nParBits     (nParBitsP)
    , .nParBitsH    (nParBitsPH)
    , .gates_fn     (gates_fn)
    , .gates_in0    (gates_in0)
    , .gates_in1    (gates_in1)
    , .gates_mux    (gates_mux)
    ) iLayer
    ( .clk          (clk)
    , .rstb         (rstb)
    , .en           (en_lay)
    , .restart      (restart)
    , .mux_sel      (muxsel_reg)
    , .v_in         (v_in)
    , .z1_chi_in_ready (z1_chi_in_ready)
    , .z1_chi       (z1_chi)
    , .z2           (z2)
    , .m_z2_p1      (m_z2_p1)
    , .z1_chi_out_ready (z1_chi_out_ready)
    , .z1_chi_out   (z1_chi_out)
    , .z2_out_ready (z2_out_ready)
    , .z2_out       (z2_out)
    , .m_z2_p1_out  (m_z2_p1_out)
    , .tau          (tau)
    , .coeff_out    (coeff_out)
    , .ready        (ready)
    , .cubic        (cubic)
    );

endmodule
