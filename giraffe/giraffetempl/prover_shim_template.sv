// synthesis VERILOG_INPUT_VERSION SYSTEMVERILOG_2012
//
// NOTE: this file is autogenerated! Modifications will be lost.
//
// Prover shim (pre-0th layer)
// (C) 2016 Riad S. Wahby <rsw@cs.nyu.edu>

`include "simulator.v"
`include "field_arith_defs.v"
`include "vpintf_defs.v"
`include "prover_shim.sv"
module prover_shim_top () ;

{0}
localparam nOutBits = $clog2(nOutputs);
localparam nOutputsRnd = 1 << nOutBits;

reg [`F_NBITS-1:0] z1 [nOutBits-1:0];
reg [`F_NBITS-1:0] z2 [nCopyBits-1:0];

wire [`F_NBITS-1:0] z1_chi_out [nOutputsRnd-1:0];
wire [`F_NBITS-1:0] m_z2_p1_out [nCopyBits-1:0];
wire [`F_NBITS-1:0] z2mz2_out [(2*nCopyBits)-1:0];
reg [63:0] field_counts [5:0];

wire ready;

genvar GateNum;
generate
    for (GateNum = 0; GateNum < 2 * nCopyBits; GateNum = GateNum + 1) begin
        if (GateNum < nCopyBits) begin
            assign z2mz2_out[GateNum] = z2[GateNum];
        end else begin
            assign z2mz2_out[GateNum] = m_z2_p1_out[GateNum - nCopyBits];
        end
    end
endgenerate

reg clk, rstb;
enum {{ ST_START, ST_RUN_ST, ST_RUN }} state_reg, state_next;
wire en_shim = state_reg == ST_RUN_ST;

wire [`F_NBITS-1:0] z1z2 [nOutBits+nCopyBits-1:0];
generate
    for (GateNum = 0; GateNum < nOutBits + nCopyBits; GateNum = GateNum + 1) begin
        if (GateNum < nOutBits) begin
            assign z1z2[GateNum] = z1[GateNum];
        end else begin
            assign z1z2[GateNum] = z2[GateNum - nOutBits];
        end
    end
endgenerate

integer i;
initial begin
    $dumpfile("prover_shim.fst");
    $dumpvars;
    if (defDebug == 1) begin
        for (i = 0; i < nOutputs; i = i + 1) begin
            $dumpvars(0, z1_chi_out[i]);
        end
        for (i = 0; i < 2 * nCopyBits; i = i + 1) begin
            $dumpvars(0, z2mz2_out[i]);
        end
        for (i = 0; i < nOutBits + nCopyBits; i = i + 1) begin
            $dumpvars(0, z1z2[i]);
        end
    end
    $display("id %d", $vpintf_init(`P_TYPE_SHIM, 0));
    clk = 0;
    rstb = 1;
    state_reg = ST_START;
    #1 rstb = 0;
    #3 rstb = 1;
end

`ALWAYS_COMB begin
    state_next = state_reg;

    case (state_reg)
        ST_START: begin
            state_next = ST_RUN_ST;
        end

        ST_RUN_ST, ST_RUN: begin
            if (~en_shim & ready) begin
                state_next = ST_START;
            end else begin
                state_next = ST_RUN;
            end
        end
    endcase
end

`ALWAYS_FF @(clk) begin
    clk <= #1 ~clk;
end

`ALWAYS_FF @(posedge clk or negedge rstb) begin
    if (~rstb) begin
        state_reg <= ST_START;
    end else begin
        state_reg <= state_next;
        if (state_reg == ST_START) begin
            if (defDebug == 1) $display("waiting (P_RECV_Z1)");
            $vpintf_recv(`P_RECV_Z1, nOutBits, z1);
            if (defDebug == 1) $display("got (P_RECV_Z1)");

            if (defDebug == 1) $display("waiting (P_RECV_Z2)");
            $vpintf_recv(`P_RECV_Z2, nCopyBits, z2);
            if (defDebug == 1) $display("got (P_RECV_Z2)");

        end else if (~en_shim & ready & (state_reg == ST_RUN)) begin
            $vpintf_send(`P_SEND_Z2VALS, 2 * nCopyBits, z2mz2_out);
            $vpintf_send(`P_SEND_Z1CHI, nOutputs, z1_chi_out);
            $f_getcnt(field_counts);
            $vpintf_send(`P_SEND_COUNTS, 6, field_counts);
            $f_rstcnt();
        end
    end
end

prover_shim
   #( .nCopyBits    (nCopyBits)
    , .nGateBits   (nOutBits)
    ) iShim
    ( .clk          (clk)
    , .rstb         (rstb)
    , .en           (en_shim)
    , .z1           (z1)
    , .z2           (z2)
    , .m_z2_p1      (m_z2_p1_out)
    , .z1_chi       (z1_chi_out)
    , .ready        (ready)
    );

endmodule
