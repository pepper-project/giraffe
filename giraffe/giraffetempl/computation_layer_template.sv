// synthesis VERILOG_INPUT_VERSION SYSTEMVERILOG_2012
//
// NOTE: this file is autogenerated! Modifications will be lost.
//
// arithmetic circuit layer
// (C) 2016 Riad S. Wahby <rsw@cs.nyu.edu>

`include "simulator.v"
`include "field_arith_defs.v"
`include "gatefn_defs.v"
`include "vpintf_defs.v"
`include "computation_layer.sv"
module computation_layer_top () ;

{0}
localparam nCopies = 1 << nCopyBits;

reg clk, rstb;
reg [`F_NBITS-1:0] invals [(nCopies*nInputs)-1:0];
wire [`F_NBITS-1:0] outvals [(nCopies*nGates)-1:0];
reg [nMuxSels-1:0] muxsel_reg;
reg [63:0] field_counts [5:0];

wire ready;
wire [`F_NBITS-1:0] v_in [nCopies-1:0] [nInputs-1:0];
wire [`F_NBITS-1:0] v_out [nCopies-1:0] [nGates-1:0];
wire [`F_NBITS-1:0] invals_wire [nCopies*nInputs-1:0];

enum {{ ST_START, ST_RUN_ST, ST_RUN }} state_reg, state_next;
wire en_lay = state_reg == ST_RUN_ST;

genvar CopyNum;
genvar InNum;
genvar OutNum;
generate
    for (InNum = 0; InNum < nCopies * nInputs; InNum = InNum + 1) begin
        assign invals_wire[InNum] = invals[InNum];
    end
    for (CopyNum = 0; CopyNum < nCopies; CopyNum = CopyNum + 1) begin
        localparam nOffset_in = CopyNum * nInputs;
        for (InNum = 0; InNum < nInputs; InNum = InNum + 1) begin
            assign v_in[CopyNum][InNum] = invals[nOffset_in + InNum];
        end
        localparam nOffset_out = CopyNum * nGates;
        for (OutNum = 0; OutNum < nGates; OutNum = OutNum + 1) begin
            assign outvals[nOffset_out + OutNum] = v_out[CopyNum][OutNum];
        end
    end
endgenerate

integer i;
initial begin
    $dumpfile("computation_layer_{1}.fst");
    $dumpvars;
    if (defDebug == 1) begin
        for (i = 0; i < nCopies * nInputs; i = i + 1) begin
            $dumpvars(0, invals_wire[i]);
        end
        for (i = 0; i < nCopies * nGates; i = i + 1) begin
            $dumpvars(0, outvals[i]);
        end
    end
    $display("id #%d", $vpintf_init(`P_TYPE_CIRCUIT, layNum));
    clk = 0;
    rstb = 1;
    state_reg = ST_START;
    #1 rstb = 0;
    #3 rstb = 1;
end

`ALWAYS_COMB begin
    state_next = state_reg;

    case (state_reg)
        ST_START: begin
            state_next = ST_RUN_ST;
        end

        ST_RUN_ST, ST_RUN: begin
            if (~en_lay & ready) begin
                state_next = ST_START;
            end else begin
                state_next = ST_RUN;
            end
        end
    endcase
end

`ALWAYS_FF @(clk) begin
    clk <= #1 ~clk;
end

`ALWAYS_FF @(posedge clk or negedge rstb) begin
    if (~rstb) begin
        state_reg <= ST_START;
    end else begin
        state_reg <= state_next;
        if (~en_lay & ready & (state_reg == ST_RUN)) begin
            $vpintf_send(`P_SEND_LAYVALS, nGates * nCopies, outvals);
            $f_getcnt(field_counts);
            $vpintf_send(`P_SEND_COUNTS, 6, field_counts);
            $f_rstcnt();
        end else if (state_reg == ST_START) begin
            if (defDebug == 1) $display("waiting (P_RECV_MUXSEL)");
            $vpintf_recv(`P_RECV_MUXSEL, 1, muxsel_reg);
            if (defDebug == 1) $display("got (P_RECV_MUXSEL)");

            if (defDebug == 1) $display("waiting (P_RECV_LAYVALS)");
            $vpintf_recv(`P_RECV_LAYVALS, nInputs * nCopies, invals);
            if (defDebug == 1) $display("got (P_RECV_LAYVALS)");
        end
    end
end

computation_layer
   #( .ngates       (nGates)
    , .ninputs      (nInputs)
    , .nmuxsels     (nMuxSels)
    , .nCopyBits    (nCopyBits)
    , .nParBits     (nParBitsP)
    , .gates_fn     (gates_fn)
    , .gates_in0    (gates_in0)
    , .gates_in1    (gates_in1)
    , .gates_mux    (gates_mux)
    ) iLayer
    ( .clk          (clk)
    , .rstb         (rstb)
    , .en           (en_lay)
    , .v_in         (v_in)
    , .mux_sel      (muxsel_reg)
    , .ready        (ready)
    , .v_out        (v_out)
    );

endmodule
